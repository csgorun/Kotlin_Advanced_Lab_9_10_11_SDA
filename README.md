# Galaxy Outpost Manager

---

###  Учебный проект на Kotlin, демонстрирующий основы объектно-ориентированного программированияиархитектурные приёмы языка. 

---
## Sealed-классы
**Sealed-классы** используются для представления ограниченного набора состояний или результатов, которыеизвестны на этапе компиляции. 

Они позволяют:

* гарантировать обработку всех возможных вариантов;
* безопасно использовать конструкцию when без else;
* удобно описывать состояния, события и результаты действий. 
### Пример: результат работы модуля
``` csharp
sealed-class ModuleResult {
    data class Success(val message: String) : ModuleResult()
    data class ResourceProduced(val resourceName: String, val amount: Int) : ModuleResult()
    data class NotEnoughResources(
        val resourceName: String, 
        val required: Int, 
        val available: Int
    ) : ModuleResult()
    data class Error(val reason: String) : ModuleResult()
}
```
## Object в Kotlin
**object** — это специальная конструкция Kotlin, которая создаёт единственный экземпляр класса (Singleton).

Особенности:

* создаётся при первом обращении;
* существует в одном экземпляре;
* не имеет конструктора. 

## Пример: глобальный логгер
``` csharp
object Logger {
private var counter = 0

    fun log(message: String) {
        counter++
        println("[$counter] $message")
    }
}
```
### Использование:
``` csharp
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```

**object** удобно использовать для:
* логгеров;
* конфигураций;
* состояний без данных в sealed-классах;
* утилитарных классов.

## Делегирование свойств 
Делегирование свойств позволяет передать логику хранения и обработки значения другому объекту. 
В Kotlin это реализуется с помощью ключевого слова by. 

Преимущества: 
1. уменьшение дублирования кода;
2. централизованная логика проверки и обработки данных;
более чистый и читаемый код. 
3. Пример: ограничение диапазона значения энергии

```kotlin
var energy: Int by Delegates.observable(100) { _, old, new ->
    println("Энергия изменилась: $old → $new")
}
```

**Lazy** (ленивая инициализация)

**lazy** позволяет инициализировать объект только при первом обращении к нему. 

Это полезно, если: 

1. объект создаётся не всегда;

2. его создание ресурсоёмкое; 

3. нужно отложить инициализацию. 

Пример: 
```kotlin
val resourceManager by lazy {
    ResourceManager()
}
```
Объект **ResourceManager** будет создан только при первом использовании. 

**Observer-паттерн** (наблюдатель)

**Observer-паттерн** позволяет объектам реагировать на изменения состояния другого объекта. 

В проекте **Galaxy Outpost Manager** наблюдатели могут: 

* реагировать на изменение ресурсов; 

* логировать события;

* уведомлять пользователя. 

Пример идеи: 

1. ResourceManager изменяет ресурсы; 

2. наблюдатель выводит сообщение в консоль при изменении. 

3. Сохранение состояния 

Для **сохранения состояния** проекта используется сериализация в JSON.

Это позволяет: 

* cохранять данные между запусками программы; 

* хранить состояние в человекочитаемом формате; 

* легко перенести логику в Android-приложение.